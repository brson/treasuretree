{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        if (!navigator.mediaDevices) return Promise.resolve(false);\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n            .then(devices => devices.some(device => device.kind === 'videoinput'))\n            .catch(() => false);\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError,\n        canvasSizeOrCalculateScanRegion = this._calculateScanRegion,\n        preferredFacingMode = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;\n        this._preferredFacingMode = preferredFacingMode;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where the third argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n            // legacy function signature where the fourth argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrCalculateScanRegion;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._calculateScanRegion = canvasSizeOrCalculateScanRegion;\n        }\n\n        this._scanRegion = this._calculateScanRegion(video);\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        this.$video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        this.$video.muted = true;\n        this.$video.disablePictureInPicture = true;\n        this.$video.addEventListener('play', this._onPlay);\n        this.$video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    /* async */\n    hasFlash() {\n        if (!('ImageCapture' in window)) {\n            return Promise.resolve(false);\n        }\n\n        const track = this.$video.srcObject ? this.$video.srcObject.getVideoTracks()[0] : null;\n        if (!track) {\n            return Promise.reject('Camera not started or not available');\n        }\n\n        const imageCapture = new ImageCapture(track);\n        return imageCapture.getPhotoCapabilities()\n            .then((result) => {\n                return result.fillLightMode.includes('flash');\n            })\n            .catch((error) => {\n                console.warn(error);\n                return false;\n            });\n    }\n\n    isFlashOn() {\n      return this._flashOn;\n    }\n\n    /* async */\n    toggleFlash() {\n      return this._setFlash(!this._flashOn);\n    }\n\n    /* async */\n    turnFlashOff() {\n      return this._setFlash(false);\n    }\n\n    /* async */\n    turnFlashOn() {\n      return this._setFlash(true);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = this._preferredFacingMode;\n        return this._getCameraStream(facingMode, true)\n            .catch(() => {\n                // We (probably) don't have a camera of the requested facing mode\n                facingMode = facingMode === 'environment' ? 'user' : 'environment';\n                return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n            })\n            .then(stream => {\n                // Try to determine the facing mode from the stream, otherwise use our guess. Note that the guess is not\n                // always accurate as Safari returns cameras of different facing mode, even for exact constraints.\n                facingMode = this._getFacingMode(stream) || facingMode;\n                this.$video.srcObject = stream;\n                this.$video.play();\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n            }\n            this.$video.srcObject = null;\n            this._offTimeout = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, scanRegion=null, qrEngine=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutScanRegion=false) {\n        const gotExternalWorker = qrEngine instanceof Worker;\n\n        let promise = Promise.all([\n            qrEngine || QrScanner.createQrEngine(),\n            QrScanner._loadImage(imageOrFileOrUrl),\n        ]).then(([engine, image]) => {\n            qrEngine = engine;\n            let canvasContext;\n            [canvas, canvasContext] = this._drawToCanvas(image, scanRegion, canvas, fixedCanvasSize);\n\n            if (qrEngine instanceof Worker) {\n                if (!gotExternalWorker) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngine.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return new Promise((resolve, reject) => {\n                    let timeout, onMessage, onError;\n                    onMessage = event => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (e) => {\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngine.addEventListener('message', onMessage);\n                    qrEngine.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    qrEngine.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return new Promise((resolve, reject) => {\n                    const timeout = setTimeout(() => reject('Scanner error: timeout'), 10000);\n                    qrEngine.detect(canvas).then(scanResults => {\n                        if (!scanResults.length) {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        } else {\n                            resolve(scanResults[0].rawValue);\n                        }\n                    }).catch((e) => reject('Scanner error: ' + (e.message || e))).finally(() => clearTimeout(timeout));\n                });\n            }\n        });\n\n        if (scanRegion && alsoTryWithoutScanRegion) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (gotExternalWorker) return;\n            QrScanner._postWorkerMessage(qrEngine, 'close');\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    /* async */\n    static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n        return ('BarcodeDetector' in window ? BarcodeDetector.getSupportedFormats() : Promise.resolve([]))\n            .then((supportedFormats) => supportedFormats.indexOf('qr_code') !== -1\n                ? new BarcodeDetector({ formats: ['qr_code'] })\n                : new Worker(workerPath)\n            );\n    }\n\n    _onPlay() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._scanFrame();\n    }\n\n    _onLoadedMetaData() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _calculateScanRegion(video) {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: (video.videoWidth - scanRegionSize) / 2,\n            y: (video.videoHeight - scanRegionSize) / 2,\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n            this._qrEnginePromise\n                .then((qrEngine) => QrScanner.scanImage(this.$video, this._scanRegion, qrEngine, this.$canvas))\n                .then(this._onDecode, (error) => {\n                    if (!this._active) return;\n                    const errorMessage = error.message || error;\n                    if (errorMessage.indexOf('service unavailable') !== -1) {\n                        // When the native BarcodeDetector crashed, create a new one\n                        this._qrEnginePromise = QrScanner.createQrEngine();\n                    }\n                    this._onDecodeError(error);\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (!navigator.mediaDevices || constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    /* async */\n    _setFlash(on) {\n        return this.hasFlash().then((hasFlash) => {\n            if (!hasFlash) return Promise.reject('No flash available');\n            // Note that the video track is guaranteed to exist at this point\n            return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: on }],\n            });\n        }).then(() => this._flashOn = on);\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _drawToCanvas(image, scanRegion=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width? scanRegion.width : image.width || image.videoWidth;\n        const scanRegionHeight = scanRegion && scanRegion.height? scanRegion.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize) {\n            canvas.width = scanRegion && scanRegion.downScaledWidth? scanRegion.downScaledWidth : scanRegionWidth;\n            canvas.height = scanRegion && scanRegion.downScaledHeight? scanRegion.downScaledHeight : scanRegionHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height\n        );\n        return [canvas, context];\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n\n    /* async */\n    static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n        return Promise.resolve(qrEngineOrQrEnginePromise).then((qrEngine) => {\n            if (!(qrEngine instanceof Worker)) return;\n            qrEngine.postMessage({ type, data });\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","navigator","mediaDevices","enumerateDevices","then","devices","some","device","kind","catch","Promise","resolve","video","onDecode","canvasSizeOrOnDecodeError","_onDecodeError","canvasSizeOrCalculateScanRegion","_calculateScanRegion","preferredFacingMode","$video","$canvas","document","createElement","_onDecode","_legacyCanvasSize","DEFAULT_CANVAS_SIZE","_preferredFacingMode","_flashOn","_paused","_active","console","warn","_scanRegion","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","playsInline","muted","disablePictureInPicture","addEventListener","_qrEnginePromise","createQrEngine","window","track","getPhotoCapabilities","result","fillLightMode","includes","error","reject","_setFlash","removeEventListener","stop","_postWorkerMessage","location","protocol","hidden","clearTimeout","_offTimeout","srcObject","play","facingMode","_getCameraStream","stream","_getFacingMode","_setVideoMirror","e","pause","setTimeout","imageOrFileOrUrl","scanRegion","qrEngine","canvas","fixedCanvasSize","alsoTryWithoutScanRegion","promise","all","_loadImage","engine","image","canvasContext","_drawToCanvas","Worker","gotExternalWorker","postMessage","type","data","timeout","onMessage","onError","event","NO_QR_CODE_FOUND","width","height","imageData","buffer","detect","scanResults","length","rawValue","message","finally","scanImage","red","green","blue","useIntegerApproximation","inversionMode","workerPath","WORKER_PATH","BarcodeDetector","getSupportedFormats","supportedFormats","indexOf","formats","_scanFrame","start","videoHeight","x","videoWidth","scanRegionSize","y","downScaledWidth","downScaledHeight","paused","ended","requestAnimationFrame","readyState","log","exact","min","constraintsToTry","forEach","constraint","_getMatchingCameraStream","getUserMedia","shift","on","hasFlash","getVideoTracks","applyConstraints","advanced","torch","style","transform","videoStream","test","videoTrack","label","scanRegionWidth","scanRegionHeight","alpha","context","imageSmoothingEnabled","drawImage","scanRegionX","scanRegionY","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad","qrEngineOrQrEnginePromise"],"mappings":"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"}